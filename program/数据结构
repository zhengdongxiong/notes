函数:
    构建一个空的、查找、插入、删除
    
常用时间复杂度
O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)

顺序表:
struct Node
{
    Type Data[MaxSize];
    int Length;  
};

链表:
struct Node
{
    Type array;
    struct Node *next;
};

p,q = head; 
while(p)
{
    p = q
    q = q->next
    free(p);
}

顺序栈:(申请一个连续的地址)
struct Node
{
    Type *base;
    Type *top;
    int Size;
};

链栈:(申请单个节点地址不连续)
struct Node (每个节点的节构)
{
    Type Data;
    struct Node *next;
};

struct ...  (链栈节构)
{
    struct Node *top;
    int Length;
};

顺序队列:(两个栈模拟 最大容量2n+1)
队空时: front=rear
队满时: (rear+1)%maxsize=front
struct Node
{
    Type Data[MaxSize];
    int front;
    int rear;
};

链队列:
struct Node (每一个节点的节构)
{
    Type Data;
    struct Node *next;
};

struct ...  (链队列节构)
{
    struct Node *rear;(指向尾的单个节点)
    struct Node *front;(指向头的单个节点)
};
销毁
while(Q->front)
{
    Q->rear=Q->front->next;
    free(Q.front);
    Q.front=Q.rear;
 }


树:
    节点的度:节点的子树个数
    树的度:树的所有节点中最大的度数
    叶节点:度为0的点
    父节点:有子树的节点是其子树的根节点的父节点
    子节点:若A节点是B节点的父节点,则称B节点是A节点的子节点,子节点也称孩子节点
    兄弟节点:具有同一父节点的各节点彼此是兄弟节点
    路径和路径长度:从N1-NK的路径为一个节点的序列。路径所包含边的个数为路径长度
    祖先节点:沿树根到某一节点路径上的所有节点都是这个节点的祖先节点
    子孙节点:某一节点的子树中的所有节点是这个节点的子孙
    节点的层次:规定根节点在1层,其余任一节点的层数是其父节点层数加1
    树的深度:树种所有节点中的最大层次是这棵树的深度
    
                                            A
                                B           C           D
                            F       G       H       I   J   K
                                    L               M
    
    A(度3-->  3个子树)                              
    B(度2-->  2个子树)


二叉树:
    二叉树第I层的最大节点数为2^(I-1)(I>=1)
    深度为K的二叉树有最大节点总数为2^K-1
    对任何非空二叉树,若N0表示叶节点的个数,N2是度为2的非叶节点个数,那么两者满足的关系N0 = N2+1
    
同构树:
    给定两颗树T1和T2,同构若T1通过干次左右孩子互换可以变成T2,则两棵树同构

顺序存储二叉树(完全二叉树)
    非根节点(序号I>1)的父节点的序号I/2(向下取整)
    节点的左孩子的序号为2I
    节点的右孩子的序号为2I+1
                            A(1)
                    B(2)            D(3)
                C(4)    S(5)    M(6)    Q(7)
            W(8)    K(9)
            
    
链式二叉树
struct Node
{
    Type Data;
    struct Node Left;
    struct Node Right;
};




遍历方法:
    先序 --- 根、左子树、右子树
    中序 --- 左子树、根、右子树
    后序 --- 左子树、右子树、根
    层次 --- 从上到下、从左到右
 
    先序遍历非递归算法
        遇到一个节点先访问,压栈,遍历左子树
        左子树遍历节束,从栈顶弹出
        按先序遍历该节点右子树
        
    中序遍历非递归算法(压栈过程为先序遍历)
        遇到一个节点,压栈,遍历左子树
        左子树遍历节束后,从栈顶弹出节点并访问
        按中序遍历该节点右子树
        1   234 56  pre[6]
        324 1   65  in[6]
        342 65  1   post[6]
    
    层序遍历
        遍历从根节点开始,将根节点入队
        执行循环
            节点出队
            访问该节点
            左右节点非空,将其左右孩子入队
            {
                //(计算深度)
                计算队列长度
                深度+1
                while(长度--)
                {
                    节点出队
                    访问该节点
                    左右节点非空,将其左右孩子入队
                }
            }   
            
    遍历应用:
        必须有中序遍历序列才能确实二叉树
        逐层剥离看根
        先序:ABCDE    FGHIJ
        中序:CBEDA    HGIJF
        整个中A是根
        BCDE是左子树    FGHIJ是右子树
        看BCDE中B是根
        C是左子树       ED是右子树
        ......

                                A
                        B               F
                    C       D       G       
                        E       H       I
                                            J
        
        高度:左子树、右子树高度+1(后序遍历)/层次遍历
        
    
二叉搜索树(二叉查找树)
    非空左子树的所有键值小于根节点的键值
    非空右子树的所有键值大于根节点的键值
    左右子树都是二叉搜索树
    
    删除:
    删除是一个叶子节点:
        找到父亲节点指向空,在释放节点
        为根的 直接释放
    删除的节点只有一个孩子节点:
        判断删除的节点在父亲的哪一边
        (1)有左子树
            父亲节点指向删除节点的左节点
            删除的是根,将根设置为删除节点的左节点
        (2)有右子树
            父亲节点指向删除节点的右孩子
            删除的是根,将根设置为删除节点的右节点
    删除的节点有左右两颗子树:
    root-删除的元素 tmp-最大最小元素 father-父亲节点
        用另一节点代替被删除节点:右子树的最小元素或者左子树的最大元素
        1、左子树最大元素
            (1)左子树最大元素的父节点是要删除的元素(删除8)(最大元素为7)
                将删除元素的左边连接到最大元素的左边
                替换删除元素和最大元素
                        8
                    7
                6   
            (2)左子树最大元素的父节点不是要删除的元素(删除8)(最大元素为9)
                将父亲节点的右边连接最大元素的左边
                替换删除元素和最大元素
                        8
                    7
                        9
                    6
            if(father != root)
                father->right = tmp->left;
            else
                root->left = tmp->left;
        2、右子树最小元素
            (1)右子树最小元素的父节点是要删除的元素(删除8)(最小元素为9)
                将删除元素的右边连接到最小元素的右边
                替换删除元素和最小元素
                        8
                            9
                                10
            (2)右子树最小元素的父节点不是要删除的元素(删除8)(最小元素为7)
                将父亲节点的左边连接最小元素的右边
                替换删除元素和最大元素
                        8
                            9
                        7
                            10
            if(father != root)
                father->left = tmp->right;
            else
                father->right = tmp->right
        

二分查找判定树 --> 对应二分查找法             1 2 3 4 5 6 7 8 9 10 11
    判定树上每个节点需要的查找次数刚好为该节点所在的层数
    查找成功时查找次数不会超过判定树的深度
    N个节点的判定树的深度为 [log(2)N]+1
    深度:
    1                               6
    2                       3               9
    3                   1       4       7       10
    4                   2       5       8       11
    ASL(平均成功查找次数) = (4*4+4*3+2*2+1)/11 = 3
    第4层4个 4*4
    第3层4个 3*4
    第2层2个 2*2
    第1层1个 1
    共11个
    
平衡二叉树(AVL树) 
    平衡因子BF BF(T) = HL-HR<=1(左子树高度-右子树高度)
    一个节点高度为0,两层的高度为1
    NH是高度为H的平衡二叉树的最小节点数
        NH = N(H-1) + N(H-2) + 1
    LL:右边旋转
        tmp = root->left;
        root->left = tmp->right;
        tmp->right = root;
                8(2平衡因子)
            7
        6       
        
    RR:左旋转
        tmp = root->right;
        root->right = tmp->left;
        tmp->left = root;
                8(2平衡因子)
                    9
                        10
                
    RL:先右后左
                1
                    3
                2
        root->right = LL(参数为右孩子)(3右旋)
                1
                    2
                        3
        RR(root)
                2
            1       3
    LR:先左后右
                1
            3
                2
        root->left = RR(参数为左孩子)
                1
            2
        3
        LL(root)
                2
            3       1
    找到被破坏者和破坏者的关系
    破坏者在被破坏者的左子树的左子树上面用LL
    以被破坏者的左子树(LL中的L)为基准进行右旋转
    
    
    破坏者在被破坏者的右子树的左子树上面用RL
    以被破坏者的右子树(RL旋转中的R)为基准进行右旋转在进行左旋转
    
    插入元素是所经过的路径压栈
    插入完毕,弹栈并判断平衡因子
    
    删除时候有左右子树进行替换转化为删除替换的元素
    删除替换的元素所经过的路径压栈
    删除完毕,弹栈并判断平衡因子
    
    1、判断不平衡因子左右子树哪个不平衡
        两边树高度的差判断
        (1)左子树
            判断插入元素与不平衡因子(被破坏者)左孩子比较
            小于LL
            大于LR
        (2)右子树
            判断插入元素与不平衡因子(被破坏者)右孩子比较
            大于RR
            小于RL

红黑树
    (1)每个节点或者是黑色,或者是红色。
    (2)根节点是黑色。
    (3)每个叶子节点(NIL)是黑色。 [注意:这里叶子节点,是指为空(NIL或NULL)的叶子节点！]
    (4)如果一个节点是红色的,则它的子节点必须是黑色的。
    (5)从一个节点到该节点的叶子节点的所有路径上包含相同数目的黑节点
    
    平衡状态下:单支黑红,或有两个子节点
    
    左旋:(被旋转的节点变为左孩子)
        对8进行左旋,8变成左节点
                8
            7       9
        (9左孩子)10    11  
        变成
                9
            8       11
        7       10(8的右孩子)
    
    右旋:(被旋转的节点变为右孩子)
        对9进行右旋
                9
            8       11
        7       10(8的右孩子)
        变成
                8
            7       9
        (9左孩子)10   11
    
    插入
        将插入节点着色为红色(保证不违背特征5)
        对于"特性(1)",显然不会违背了。因为我们已经将它涂成红色了。
        对于"特性(2)",显然也不会违背。在第一步中,我们是将红黑树当作二叉查找树,然后执行的插入操作。而根据二叉查找数的特点,插入操作不会改变根节点。所以,根节点仍然是黑色。
        对于"特性(3)",显然不会违背了。这里的叶子节点是指的空叶子节点,插入非空节点并不会对它们造成影响。
        对于"特性(4)",是有可能违背的
        
        出现情况
        1、被插入的节点是根节点
            将此节点涂为黑色
        2、被插入的节点的父节点是黑色
            不做变换
        3、被插入的节点的父节点是红色
            与特性4违背
            case1:当前节点的父节点是红色,且当前节点的祖父节点的另一个子节点也是红色
                将父节点设为黑色
                将叔叔节点设为黑色
                将祖父节点设为红色
                将祖父节点设为当前节点,之后对当前节点操作
            case2:当前节点的父节点是红色,叔叔节点是黑色,且当前节点是其父节点的右孩子
                将父节点作为新的当前节点
                以新的当前节点为支点进行左旋
            case3:当前节点的父节点是红色,叔叔节点是黑色,且当前节点是其父节点的左孩子
                将父节点设置为黑色
                将祖父节点设为红色
                以祖父节点为支点进行右旋
    
    删除
        第一步
            case1:被删除的节点没有孩子
                直接删除
            case2:被删除的节点只有一个孩子
                直接删除,孩子节点顶替它的位置
            case3:被删除节点有两个孩子
                找出后继节点,把后继节点内容复制给该节点
                改为删除后继节点(后继节点为黑色需要修正,修正对象为左/右孩子)
            
        第二步
            修正
                通过RB-DELETE算法,我们知道:删除节点y之后,child(x)占据了原来节点y的位置。 既然删除y(y是黑色),意味着减少一个黑色节点；
                那么,再在该位置上增加一个黑色即可。这样,当我们假设"x包含一个额外的黑色",就正好弥补了"删除y所丢失的黑色节点",也就不会违反"特性(5)"。 
                因此,假设"x包含一个额外的黑色"(x原本的颜色还存在),这样就不会违反"特性(5)"。
                现在,x不仅包含它原本的颜色属性,x还包含一个额外的黑色。即x的颜色属性是"红+黑"或"黑+黑",它违反了"特性(1)"。
                现在,我们面临的问题,由解决"违反了特性(2)、(4)、(5)三个特性"转换成了"解决违反特性(1)、(2)、(4)三个特性"。RB-DELETE-FIXUP需要做的就是通过算法恢复红黑树的特性(1)、(2)、(4)。RB-DELETE-FIXUP的思想是:将x所包含的额外的黑色不断沿树上移(向根方向移动),直到出现下面的姿态:
                假设child额外多一个黑色
                a) x指向一个"红+黑"节点。此时,将x设为一个"黑"节点即可。
                b) x指向根。此时,将x设为一个"黑"节点即可。
                c) 非前面两种姿态。
                case1:child为红节点/根节点
                    直接涂黑
                兄弟节点右子树
                case2:child是“黑+黑”节点,且x不是根。
                    case1:x的兄弟节点是红色(此时x的父节点和x的兄弟节点的子节点都是黑节点)
                        将x的兄弟节点设为“黑色”。
                        将x的父节点设为“红色”。
                        对x的父节点进行左旋。
                        左旋后,重新设置x的兄弟节点。
                    case2:x的兄弟节点是黑色,两孩子都是黑色(必有左右孩子)(!other->left || rb_is_black(other->left)) && (!other->right || rb_is_black(other->right))
                        将x的兄弟节点设为“红色”。
                        设置“x的父节点”为“新的x节点”。
                    case3:x的兄弟节点是黑色；x的兄弟节点的左孩子是红色,右孩子是黑色的。
                        将x兄弟节点的左孩子设为“黑色”。
                        将x兄弟节点设为“红色”。
                        对x的兄弟节点进行右旋。
                        右旋后,重新设置x的兄弟节点。
                    case4:x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的,x的兄弟节点的左孩子任意颜色。
                        将x父节点颜色 赋值给 x的兄弟节点。
                        将x父节点设为“黑色”。
                        将x兄弟节点的右子节设为“黑色”。
                        对x的父节点进行左旋。
                        置“x”为“根节点”。
                        
        
堆:(删除在头,插入在尾,保持完全二叉树,最大最小堆)
    从下标1开始
    在下标为0放一个哨兵作为界限(程序效率提高)

    
    性质:完全二叉树 或 近似完全二叉树(不是满二叉树的完全二叉树)。
        分类:最大堆:父节点的值不小于子节点；最小堆:父节点的值不大于子节点。
        左右子节点:没有大小的顺序。
        堆的存储: 
        一般都用数组来存储堆。下标为i的节点的父节点的下标为(i–1)/2。根节点的左右子节点下标分别为 2i+1 和 2i+2。
        例如:下标为0的节点左右子节点的下标分别为1和2。

    
struct Node
{
    Type *Data;
    int Size;       //当前元素个数
    int Capacity;   //堆最大容量
};
    插入算法；(大堆)
        i = Heap->Size; //当前元素位置+1 要插入的地方
        //父节点为i-1/2
        while(Heap->Data[(i-1)/2] < Insert)
        {
            Heap->Data[i] = Heap->Data[i-1/2];
            i = (  i-1)/2;
        }//找到父节点比插入元素要大
        //插入位置
        Heap->Data[i] = Insert;
    删除:(大堆)
        Max = Heap->Data[0];
        tmp = Heap-Data[Heap->Size-1];  //取出最后元素
        for(Parent = 0; Parent*2+1<=H->Size(判断是否有左儿子); Parent = Child)
        {
            Child = Parent*2+1;
            if((Child < Heap->Size-1) && Heap->Data[Child] < Heap->Data[Child+1])   //右边比左边大
                Child++;
            if(tmp >= Heap->Data[Child])
                break;
            else
                Heap->Data[Parent] = Heap->Data[Child];
        }//替补上来的元素比要比较的大
        //要插入的位置
        Heap->Data[Parent] = tmp;
    建立:(大堆)
        for(i = (Heap->Size-1)/2; i >= 0; i--)
        {
            Child = i*2+1;//左孩子
            if(( Child < Heap->Size-1) && ( Heap->Data[Child] < Heap->Data[Child + 1] ))
                Child++;
            if(Heap->Data[Child] > Heap->Data[i])
                Swap(&Heap->Data[Child], &Heap->Data[i]);
        }
        
哈夫曼树:
    将两个权值最小的两个值作为新一颗树的左右子树
    没有度为1的节点
    N个叶子节点的哈夫曼树共有2N-1个节点
struct Node
{
    Type Data;
    struct Node *Left, *Right;
};
    堆的元素数据类型是哈夫曼节点
    
    1   2   3   4   5 
                    15  
            6               9
        3       3       4           5
    1       2
    
    (1)先将节点构造成最小堆
    for(i=0; i<H->Size-1; i++)(H->Size-1次合并)
    {
        (2)逐渐取出(删除)最小堆元素 合并成新的节点
        (3)将新根节点的值插入最小堆里面
    }
    T = 取出最后的一个节点(删除)
    
哈夫曼编码
    最优编码--总长度(WPL)最小
    无歧义解码--前缀码:数据仅存在于叶子节点
    没有度为1的节点--满足1、2必然有3
            5                                   5
        4       1                           3       2
    2       2                           1       2
                2*2+2*2+1*1 = 9(叶子节点的数据*路径长度)
    最优编码:   1*2+2*2+1*2 = 8
    编码数组长度:树深度-1
    一棵树的WPL为左子树+右子树的WPL
    int WPL(Tree T, int Depth(为根的深度))
    {
        if(!T->Left && !T->Right)
            return (T->weight * Depth);
        else
            return (WPL(T->Left, Depth+1) + WPL(T->Right, Depth+1)) ;
    }
集合:
struct Node
{
    Type Data;(用数组下标代替数据)       0存放在[0] 
    int Parent;
};
    数组存储
    根节点的负数的值为下面有多少个元素
    S1 = {1,2,3}
    S2 = {4,5,6,7}
    2,3的父亲节点为1
    下标  Data    Parent  
    0       1       -1
    1       2       0
    2       3       0
    3       4       -1
    4       5       3
    5       6       3
    6       7       3
    找所属的集合
        for(i=0; i<MaxSize && S[i].Data != x; i++);(用数组下标代替数据)可以去除0存放在[0] 提高效率
        for(; S[i]>=0; i = S[i]);
        i为所在的集合
    并运算:
    找两个元素的的父,将其中一个的父节点设置成另一个根节点的下标
    路径压缩:
    1                                   1                           
        2                           2   3   4
            3
                4
    //找到所有子树的父节点x是查找的数父亲节点为A[x]     查找4 A[4]中的数3为父亲节点 
    x;//查找x的祖父节点
    while(father >= 0)
        father = A[father]; //father为祖父节点
    while(x != father)
    {
        tmp = A[x];         //tmp为A[son]的父亲节点                                   
        A[x] = father;      //son的父亲节点改为 祖父节点
        x = tmp;            //son变为 
    }
    
图:
    一组顶点:V表示顶点集合
    一组边:E表示边集合
    边是顶点对:(v,w)∈E 其中v,w∈V    v---w
    有向边:<v,w>           v-->w
    度:从该点出发的边数为"出度",指向该点的边为"入度"
    邻接矩阵
        无向图:对应行/列非0元素的个数
        有向图:行非0的个数是"出度",列非0个数"入度"
        存储图:用N(N+1)/2 下标位置(i*(i+1)/2 + j)   A(63)
    邻接表:指针数组
    图的遍历:
        DFS:深度优先搜索 栈
        BFS:广度优先搜索 队列
    连通图:任意一对顶点连通
        连通分量:无向图的极大连通子图
        (1)、要是子图； 
        (2)、子图要是连通的； 
        (3)、连通子图含有极大顶点数； 
        (4)、具有极大顶点数的连通子图包含依附于这些顶点的所有边；
            极大顶点数:再加一个顶点就连不通了
            极大边数:子图中所有顶点相连的所有边
        强连通:顶点V,W之间存在双向路径,则V,W是强连通
        强连通图:有向图中任意两顶点均强连通
        强连通分量:有向图的极大连通子图
        弱连通图:将有向图的所有的有向边替换为无向边,所得到的图称为原图的基图。如果一个有向图的基图是连通图,则有向图是弱连通图。

散列表:
    建立映射关系,通过key值找到数据插入/查找位置 
    冲突处理:
        换位置:开放地址法(按某种规则找另一个位置)
            线性探测:+i
            平方探测:+-i^2 (删除 做一个标记并不是从表中删除 (有元素进来 && 标志已删除)替代元素)
            d       +1^2    -1^2    +2^2    -2^2
            Cnum    1       2       3       4
            int Find(.....) //查找位置
            {
                while(位置!= 空 && 里面值 != key) //发生冲突
                {
                    if(++CNum%2)    //  冲突奇偶处理
                    {
                        NewPos = CurrentPos + (CNum+1)/2 * (CNum+1)/2;
                        while(NewPos>=表长度)
                            NewPos -= 表长度;
                    }
                    else
                    {
                        NewPos = CurrentPos + CNum/2 * CNum/2;
                        while(NewPos < 0)
                            NewPos += 表长度;
                    }
                }

            }
            
            双散列:设计另一个散列函数
            再散列:重新设计一个散列表比原来大
            ASLs(成功查找):
            ASLu(不成功):
        同一个位置冲突对象组织在一起:链地址法