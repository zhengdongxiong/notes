Linux内核主要由五个子系统组成:进程调度,内存管理,虚拟文件系统,网络接口,进程间通信。

BIOS
    post通电自检
    将Bootloader从磁盘的主引导扇区(512bytes)加载到内存执行(0:7C00)

Bootloader
    将操作系统的代码从数据从硬盘加载到内存
    446(Bytes)
        启动代码
    16*4(Bytes)
        第1-4个分区表项
    2(Bytes)
        签名0x55,0xAA
    
系统调用
    产生:应用程序请求操作提供服务(同步/异步)
    响应:等待和持续
    处理
        用户态-->内核态
        用户态堆栈-->内核态堆栈
    跨越操作系统边界的开销
        执行时间上比程序调用长
        建立中断/异常/系统调用号的对应服务
        例程映射关系的初始化开销
        建立内核堆栈
        验证参数
        内核态映射到用户态的地址空间
            更新页面映射权限
        内核态独立地址空间
            TLB
异常
    产生:应用程序异常(同步)
    响应:杀死或者重新执行意向不到的应用程序命令
    处理(有异常编号)
        保存现场
        异常处理
            杀死产生异常的程序
            重新执行异常指令
        恢复现场
中断
    产生:外设(异步)
    响应:持续,对用户应用程序是透明
    处理
        硬件
            设置中断标记    
                将内部、外部世界设置中断标记
                中断事件的ID
        软件
            保存当前处理状态
            中断服务程序处理
            清除中断标记
            恢复之前保存的处理状态
内存管理
    目标
        抽象:逻辑地址空间
        保护:独立地址空间
        共享:访问相同内存
        虚拟化:更多的地址空间
    方法
        分段
        分页
        虚拟内存
        按需分页虚拟内存
    依赖
        内存架构
        MMU    
    地址空间
        逻辑地址(虚拟)
        物理地址(真实存在)
        
    体系结构
        CPU        内存       IO
        |         |           |
        --------总线--------
        CPU                                                    内存
            运算器                                                CPU寄存器
            寄存器                                                L1缓存
            缓存                                                  L2缓存
            存储管理单元(MMU)(查找物理-->逻辑内存映射)              |(cache miss/fill)
            控制器                                                主存
                                                                    |(交换/分页)
                                                                  磁盘(虚拟内存)        
    地址安全检查
        操作系统设置虚拟内存基址与边界            
    连续内存分配
        内存碎片问题
            空闲内存不能被利用
                外部:分配单元之间的未使用内存
                内部:分配单元中的未使用
        分区的动态分配
            首次适配
            最佳适配
            最差适配
        压缩式碎片整理
            分配单元之间位置调整
        交换式碎片整理
            利用硬盘空间                       
    虚拟内存
        覆盖技术
            用A函数时用不到B C函数时可以三者共用一块内存
        交换技术
            可将暂时不能运行的程序送到外存
        虚存技术
            上面两种结合，采用页式存储管理技术，并增加请求调页与页面置换
            要求程序的局部性原理
                时间局部性:一条指令/数据的一次执行和下次执行集中在较短的时期内
                空间局部性:当前指令/数据和邻近的指令/数据都集中在一个较小区域
            装入程序时,不必全部装入内存,将当前需要执行的部分页面装入内存
            执行过程中,指令/数据未在内存,发出缺页中断请求,操作系统调入内存中        
        地址空间
            0xc0000000 ~ 0xFFFFFFFF(1G)
                内核空间
                    ZONE_HIGHMEN(128M)                   
                    ZONE_NORMAL(892M)
                    ZONE_DMA(16M)
            0x00000000 ~ 0xc0000000(3G)
                用户空间
                    envp
                        环境变量
                    argv
                        命令行参数
                    stack
                        地址由高到低扩展,连续的
                    libc.so
                        .a 静态库
                            生成链接的时候已经包含进来
                        .so 动态库
                            运行时才加载
                    heap
                        动态分配内存,地址由低到高扩展
                    .bss
                        程序中未初始化以及初始化为0的全局/静态变量,程序载入时有内核清0,不连续
                    .date
                        存放在编译阶段(而非运行时)就能确定的数据,可读可写,静态存储区
                            赋值的全局/静态变量,常量
                    .text(代码段)
                        可执行文件加载到内存中的只有数据和指令之分,指令存放在此,一般共享,编译时确定,只读,不允许修改
                    .reserve(预留) 128M 0x08048000
                        进程禁止访问           
        页式内存管理
            地址空间S位,m位为帧/页位数,n位为每帧/页大小
                n = S - m
                帧/页总数 = 2^m
                每帧/页大小 = 2^n(Bytes)                
            帧(Frame)--物理内存被分割为大小相等的帧
                f--帧号(F位,共有2^F个帧)
                o--帧内偏移(S位,每帧共有2^S字结)
                物理地址 = 2^S * f + o
                    16bit的地址空间,9bit大小的页帧
                        F = 7bit 共128帧
                        S = 9bit 共表示一帧有512bytes
                    物理地址 = (3,6)
                    物理地址 = 512 * 3 + 6 = 1542                    
            页--逻辑地址空间被划分为大小相等的页
                页号大小 >= 帧号大小(可能一样,或者页号大于帧号)
                页内偏移大小 = 帧内偏移的大小
                p--页号(P位,共有2^P个页)
                o--页内偏移(S位,共有2^S个字结)
                逻辑地址 = 2^S * p + o
                    20bit的地址空间,9bit大小的页帧
                        P = 11bit 共2048页
                        S = 9bit 共表示一页有512bytes
                    逻辑地址 = (3,6)
                    逻辑地址 = 512 * 3 + 6 = 1542            
            页表(页号与帧号之间的映射)
                二级/多级页表
                    能减少内存空间,用不到的二级页面不需要放在内存中
                    40位 8位一级  10位二级  10位三级 12位页大小(4K = 4096)(三级页表)
                    32位中页大小4KB，一个页表项4B,页表项个数 = 1024 = 2^10,最多分级位数<=10,超过10位一页存不下
                页表项内容
                    [31:22]:一级页表
                    [21:12]:二级页表
                    [11:0] :标志位(由于页大小4KB = 2^12(低12位空闲可以作其它用途))
                    31-----------------12---------------0
                    |逻辑页号--物理帧号|     标志位     |
                    -------------------------------------
                        P[0]:存在位。为1表示页表或者页位于内存中。否则，表示不在内存中，必须先予以创建或者从磁盘调入内存后方可使用。 
                        R/W:读写标志。为1表示页面可以被读写，为0表示只读。当处理器运行在0、1、2特权级时，此位不起作用。页目录中的这个位对其所映射的所有页面起作用。 
                        U/S:用户/超级用户标志。为1时，允许所有特权级别的程序访问；为0时，仅允许特权级为0、1、2的程序访问。页目录中的这个位对其所映射的所有页面起作用。 
                        PWT:Page级的Write-Through标志位。为1时使用Write-Through的Cache类型；为0时使用Write-Back的Cache类型。当CR0.CD=1时（Cache被Disable掉），此标志被忽略。对于我们的实验，此位清零。 
                        PCD:Page级的Cache Disable标志位。为1时，物理页面是不能被Cache的；为0时允许Cache。当CR0.CD=1时，此标志被忽略。对于我们的实验，此位清零。 
                        A:访问位。该位由处理器固件设置，用来指示此表项所指向的页是否已被访问（读或写），一旦置位，处理器从不清这个标志位。这个位可以被操作系统用来监视页的使用频率。 
                        D:脏位。该位由处理器固件设置，用来指示此表项所指向的页是否写过数据。 
                        PS:Page Size位。为0时，页的大小是4KB；为1时，页的大小是4MB（for normal 32-bit addressing ）或者2MB（if extended physical addressing is enabled). 
                        G:全局位。如果页是全局的，那么它将在高速缓存中一直保存。当CR4.PGE=1时，可以设置此位为1，指示Page是全局Page，在CR3被更新时，TLB内的全局Page不会被刷新。 
                        AVL[11]:被处理器忽略，软件可以使用。
                    页表项大小 = 页表项位数 / 8 = 4B(32位中)
                    多少个页号(一个页号对应一个页表项) = 页大小 / 页表项                    
                每个运行的程序都有一个页表
                    PTBR:页表基址寄存器                
                性能问题
                    两次访问 一次用于获取页表项 一次访问数据
                    页表可能很大
                        缓存
                        间接访问                        
                TLB
                    缓存近期访问的页帧转换表项
                        TLB使用associative memory(关联内存)实现
                        如命中,物理页可以很快被获取
                        未命中,对应的表项被更新到TLB中
                        32位系统中,通常页大小为4KB,TLB通常访问4K次才发生缺页
                            (3,0)...(3,4k)所有第3页都可以查TLB表得到映射
                反向页表
                    以帧号建立表
                        存在问题如何通过页号找到帧号
                    基于页寄存器方案:以帧号为索引号,每个帧和一个寄存器关联,寄存器包括(页寄存器)
                        此帧是否被占用
                        对应的页号
                        保护位
                        优势:占用空间小
                            物理内存 16M
                            页面大小 4K
                            页帧数      4K(16MB / 4K = 4K)
                            页寄存器占用空间(假设8B) 8B * 4098 = 32KB
                            页寄存器开销 32K / 16M = 0.2%
                        劣势:难通过页号找到帧号
                    基于哈希查找的方案                           
        缺页中断过程
            1、如果在内存中有空闲的物理页面,则分配一物理页帧f,然后转到第四步,否则转到第二步
            2、采用某种页面置换算法选择一个将要被替换的物理页帧f,如果该页在内存间被修改过,则写回外存
            3、对q所对应的页表项进行修改,把驻留位置为0
            4、将需要访问的页p装入到物理页面帧f中
            5、修改p所对应的页表项内容,把驻留位置为1,把物理页帧号置为f
            6、重新执行被中断的指令        
        后备存储
            一个虚拟地址空间的页面可以被映射到一个文件的某个位置
            代码段:映射到可执行二进制文件
            动态加载的共享库:映射到动态调用的库文件
            其它:可能被映射到交换文件       
        性能
            effective memory access time(EAT) = page fault处理时间 * page fault几率
            访存:10ns
            磁盘访问时间:5ms
            参数p = page fault几率
            参数q = dirty page几率
            EAT = 10(1-p) + 5000000p(1 + q)
        
        页面置换算法
            缺页中断发生,需要调入新的页面而内存已满时候,选择内存当中哪个物理页面被置换
            局部
                先进先出(FIFO)
                    选择在内存中驻留时间最长的页面淘汰
                最近最久未使用(LRU)
                    选择最久未使用的那个页面淘汰
                    维护一个链表,最近使用过的作为首结点,最久未使用的作为尾结点
                    堆栈,访问页时,将页号压入栈顶,然后查看栈内有无与此页相同页号,若有则抽出,需要置换时选择栈底抽出
                时钟页面置换
                    把各个页面组织成环形,指针指向最老的页面,产生缺页中断时,查看指针所指向页面的访问位,为0则淘汰,为1则置0,往下移搜索
                二次机会法
                    使用脏位与使用为来指导置换
                    0 0置换;0 1 将脏位置0 --> 0 0;1 1 -- > 0 1
                最不常用(LFU)
                    选择访问次数最少的那个页面
                    对每个页面设置一个访问计数器,当被访问时,该页面的访问计数器加1,淘汰数值最小的那个
            全局(为进程分配可变数目的物理页面)
                工作集
                    一个进程当前正在使用的逻辑页集合,二元函数W(t,δ)
                    t当前的执行时刻
                    δ工作集窗口 如10,一次加载10帧
                    |W(t,δ)| 工作集大小,即页面数目
                        2615777751(t1) 623412 3444343444(t2) ,δ = 10
                        |W(t1,δ)| = {1,2,5,6,7}
                        |W(t2,δ)| = {3,4}
                常驻集
                    当前时刻,进程实际驻留在内存当中               
                工作集置换
                    页不属于工作集窗口直接丢弃
                缺页率页面置换算法
                    常驻集大小可变,进程缺页率较高,增加常驻集以分配更多的物理页面,反正,减少常驻集以减少物理页面                    
                缺页率 = 缺页次数 / 内存访问次数
                当缺失发生时,从上次页缺失计算这个时间记录这个时间,t(last)是上次的缺页时间
                t(current) - t(last) > T,从内存中移除所有在(t(current) - t(last))之间内没有被引用的页
                t(current) - t(last) < T,增加缺失页到工作集中

进程
    进程描述
        进程的定义
            一个具有一定独立功能的程序在一个数据集合           
        进程的组成
            程序的代码
            处理的数据
            程序计数器中的值,指示下一条将运行的指令
            一组通用的寄存器的当前值,堆,栈
            包含正在运行的一个程序的所有状态信息
        进程的特点
            动态性
            并发性:进程可以被独立调度并占用处理运行,并发并行
            独立性:不同进程的工作不相互影响
            制约性:访问共享数据/资源或进程间同步而产生制约
        进程控制块PCB
            OS管理控制进程运行所用的信息集合,描述进程的基本情况以及运行变化的过程,是进程存在的唯一标识,没PCB,OS分配不了资源给程序
            PCB包含三大类
                标识信息
                    本进程的标识,父进程标识,用户标识
                处理机状态信息保存区
                    用户可见寄存器
                        用户程序可以使用的数据,地址等寄存器
                    控制的状态寄存器
                        程序计数器(PC),程序状态字(PSW)
                    栈指针
                        过程调用/系统调用/中断处理和返回时需要用到它
                进程控制信息
                    调度和状态信息
                        用于操作系统调度进程并占用处理机使用
                    进程间通信信息
                        支持进程间与通信相关的各种标识、信号,存在接收方的进程控制块中
                    存储管理信息
                        指向本进程映像存储空间的数据结构                     
                    进程所用资源
                        由进程打开、使用的系统资源、如打开的文件等
                    有关数据结构连接信息
                        进程可以连接到一个进程队列中或连接到相关的其它进程的PCB
            组织方式
                链表
                    同一状态的进程其PCB成一链表,多个状态对应多个不同的链表
                索引表
                    同一状态的进程归入一个index表,多个状态对应多个index表
                队列
                    同一状态的进程其PCB组成一个队列
    进程状态
        进程的生命周期管理
            创建
                系统初始化
                用户请求
                正在运行的进程执行了创建进程的系统调用
            运行 内核选择一个就绪的进程,占用处理机执行
            等待 进程阻塞,只能自己阻塞自己,因为只有进程自身知道何时需要等待某种事件发生
                请求并等待系统服务,无法马上完成
                启动某种操作,无法马上完成
                需要的数据没有达到
            唤醒 只能被别的进程或操作系统唤醒
                被阻塞进程需要的资源可以被满足
                被阻塞进程等待的事件到达
                该进程的PCB插入到就绪队列
            挂起 将进程从内存转到外存
            结束
                正常退出
                错误退出
                致命错误
                被其它进程所杀
        Linux中进程的七种状态
            R运行状态（runing）：并不意味着进程一定在运行中，也可以在运行队列里；
            S睡眠状态（sleeping）：进程在等待事件完成；（浅度睡眠，可以被唤醒）
            D磁盘睡眠状态（Disk sleep）:不可中断睡眠（深度睡眠，不可以被唤醒，通常在磁盘写入时发生）
            T停止状态（stopped）：可以通过发送SIGSTOP信号给进程来停止进程，可以发送SIGCONT信号让进程继续运行
            X死亡状态（dead）:该状态是返回状态，在任务列表中看不到；
            Z僵尸状态（zombie）:子进程退出，父进程还在运行，但是父进程没有读到子进程的退出状态，子进程进入僵尸状态；
                僵尸进程是由于父进程没有读取到子进程的退出信息而产生的，那么我们是不是就可以理解为父进程一直以为处于僵尸状态的子进程是没有退出的。
              而进程是需要维护的，僵尸进程就会一直需要PCB对其进行维护；
                浪费内存资源。如果僵尸进程一直没有退出，就会一直占用这块内存，就会导致内存资源的浪费；
                内存泄漏。僵尸进程一直占用资源，但是却不使用，就可能会导致内存泄漏。
                为什么需要父进程回收
                    进程执行完成时,无法回到用户空间执行清除自身PCB,无PCB,OS不会分配资源给进程,无法运行,所以自身无法回收自身的PCB
            t追踪停止状态（trancing stop）   
        
    线程
        优点
            独立运行单位
            共享进程地址空间,并发执行
            进程把一组相关的资源组合起来,构成一个资源平台,包括地址空间
            一个进程中可以同时存在多个线程
        缺点
            一个线程崩溃,导致所属进程的所有线程崩溃           
        进程是资源分配单位,线程是CPU调度单位
        进程拥有一个完整的资源平台,线程只独享必不可少的资源
        具有基本状态,同样具有之间的转换状态
        线程减少并发执行的时间和空间开销
            创建时间比进程短
            线程的终止时间比进程短
            同一进程内的线程切换时间比进程短
            由于同一进程的各线程间共享内存和文件资源,可之间进行不通过内核的通信
        用户线程
            用户级的线程库完成线程的管理,内核不管理,TCB由线程库管理,每个进程有自己的TCB列表
            缺点
                执行一个系统调用而阻塞,整个进程在等待
                一个线程开始运行后,除非主动交出CPU的使用权,否则其它线程无法运行
                每个线程得到的时间片很少
        内核线程
            TCB在内核中
            线程管理由操作系统管理
            时间片直接给线程
        轻量级线程
            内核支持的用户线程,一个进程可有一个或者多个轻量级进程,每个量级进程由一个单独的内核线程来支持
            
    进程控制
        写时复制
            fork产生一样的子进程,fork之后exec之前子进程与父进程指向相同的物理空间,父子进程有相应修改段操作时,再分配空间
    调度
        内核运行调度程序条件
            一个进程从运行到等待
            进程被终结
        不可抢占
            调度程序必须等待事件结束
        可以抢占
            调度程序在中断被响应后执行
            当前的进程从运行切换到就绪,或者一个进程从等待切换到就绪
            当前运行的进程可以被换出
        原则
            CPU使用率
                处于忙状态占比
            吞吐量
                单位时间内完成的进程数量
                减少开销
                系统资源的高效利用(CPU,I/O设备)
            周转事件
                一个进程从初始化到结束,包括所有等待所花费时间
            等待原则
                在就绪队列的总时间
                减少等待时间
            响应时间
                从一个请求被提交到产生第一次响应所花费的总时间
                减少响应时间
                减少平均响应时间
        调度算法
            FIFO 先来先服务
                P1 12s P2 3s p3 3s
                到达顺序 P1 P2 P3
                    周转时间(12+15+18)/3 = 15
                到达顺序 P2 P3 P1
                    周转时间(3+6+18)/3 = 9
            SPN(SJF) SRT 短进程优先(短作作业优先)短剩余时间优先
                短任务优先
                抢占/非抢占
            HRRN 最高响应比优先
                R = ( W + S )/S 
                    W 等待时间 S执行时间
            Round Robin 轮循
                P1 53s P2 8s P3 68s P4 24s
                  P1 P2 P3 P4 P1 P3  P4  P1  P3  P3
                 0 20 28 48 68 88 108 112 125 145 153
                等待时间
                    P1 = (68-20)+(112-88) = 72
                    P2 = (20-0) = 20
                    P3 = (28-0)+(88-48)+(125-108) = 85
                    P3 = (48-0)+(108-68) = 88
                平均时间
                    (72+20+85+88)/4 = 66 
            Multilevel Feedback Queues 多级反馈队列
                n级优先级-优先级调度在所有级别中,RR在每个级别中
                    时间片随优先级增加而减小
                    如果任务在当前时间片没有完成,则降到下一个优先级
            Fail Share Scheduling 公平共享调度
                CFS
            实时调度
                强实时 必须完成
                弱实时 尽量完成
            多处理器调度
            优先级翻转
            
进程间通信
    资源共享
        原子操作:一次不存在任何终端或者失败的执行
            该执行成功结束,或根本没有执行,并且不应该发现任何部分执行的状态,不可被打断的操作,开始就运行到结束
        临界区
            进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时,不会被执行的代码区域
            将共享资源放入临界区,进入临界区(加锁),离开临界区(解锁)
            特征
                互斥
                    一个进程处于临界区时,没有其他进程会处于临界区
                有限等待
                    一个线程I处于入口去,在I的请求被接受之前,其他线程进入临界区的时间是有限制的
                无忙等待
                    如果一个进程在等待进入临界区,那么在他可以进入之前会被挂起
            方法
                禁用硬件中断
                    进入临界区禁用中断,离开临界区使能中断,适用临界区使用时间短
                软件解决方法
                    共享共有变量同步行为,设置变量表示该谁进入临界区,必须等待用完临界区
                    trun 表示该谁进入临界区 flag表示是否准备好进入临界区
                        Dekker Bakery Peterson算法
                抽象方法
                    硬件提供原子操作
                        锁
                        Test and Set
                            从内存中读取值,该值是否为1(返回布尔),内存值无论是否为1均设置为1,其余读取后不可访问
                            流程
                                锁被释放,Test and Set读取0设置为1,锁设置为忙,且需要等待完成
                                锁处于忙,Test and Set读取1设置为1,锁状态不变,并需要循环(自旋)
                        交换
                            交换内存中的两个值
                            流程
                                设置两个值,lock = 0 key = 1,
                                    int lock = 0;
                                    int key;
                                    do {
                                        key = 1;
                                        while(key == 1) {
                                            exchange(lock,key); // key = 0 lock =1
                                        }
                                        critical section
                                        lock = 0;
                                        remainder section
                                    }
                        设置忙等非忙等
                            进程等待临界区资源后,让进程处于睡眠状态(适用于临界区较长),让进程处于等待(适用临界区较短)
                                上下文切换开销取决用忙等还是非忙等
        将共享资源放入临界区,进入临界区(加锁),离开临界区(解锁)
        死锁
            两个或以上的进程,在相互等待完成特定任务,最终没法将自身任务进行下去
        饥饿
            一个可执行的进程,被调度器持续忽略,以至于虽然处于可执行状态却不被执行
    加速
    模块化
    信号量(共享资源)
        P操作:-1 信号量<0等待,否则继续执行,可以阻塞
            P() {
                sem--;
                if (sem < 0) {
                    add.queue;
                    block();
                }
            }
        V操作:+1 信号量<=0(证明有等待该资源进程,离开临界区,让别的进程执行),唤醒一个等待的进程,不会阻塞
            V() {
                sem++;
                if (sem <= 0) {
                    remove.queue
                    wakeup();
                }
            }
            进入临界区前执行P操作,离开临界区执行V操作
        类型
            二进制0/1,计数信号量(非负)
        用途
            条件同步(调度约束,一个进程等待另一个进程的事情发生),每个信号量约束一个条件
                任何一个时间,只能有一个线程操作缓冲区
                    设置二进制信号量,mutex(1)
                缓存区为空,消费者必须等待生产者
                    full(0)
                缓存区为满,生产者必须等待消费者
                    empty(n)
                    
            生产者          消费者
                empty.P         full.P
                mutex.P         mutex.P
                add.buff        remove.buff
                mutex.V         mutex.V
                full.V          empty.V
            假设生产者P操作互换,先执行mutex.P造成死锁,临界区资源满即empty=0,造成死锁
    管程
        管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块
        组成
            共享资源
            共享资源操作函数
            条件变量(只能wait,signal操作),用于维护等待资源的队列,等待/通知信号量用于管理并发访问信号量   
                条件变量buff
                    缺少buff,执行buff.wait(),加入buff资源等待队列,其它进程释放buff资源,调用buff.signal唤醒需要buff资源的进程
                    只能由buff.signal唤醒
        Lock
            lock.Acquire
            lock.Release
        Condition Variable
            运行等待状态进入临界区
            wait() { //释放锁,让其他进程执行,自身睡眠
                num_wait++;
                add.queue;
                release.lock;
                schedule(); //选择适合进程调度,再次被调度后,往下执行
                acquire.lock;
            }
            signal() { //唤醒等待
                if (num_wait > 0) {
                    remove.queue;
                    wakeup();//唤醒等待的进程,等待被调度
                    num_wait--;
                }
            } 
            strurct {
                lock;
                count;//用户表示共享资源数量,根据条件变量设计
                condition full,empty;//条件变量
            }
            生产者                 消费者
                lock.Acquire           lock.Acquire
                while(count == n)      while(count == 0)
                    full.wait()            empty.wait()
                add.buff               remove.buff
                count++                count--
                empty.signal()         full.signal()
                lock.Release           lock.Release
    
    读者-写者问题
        读者:不需要修改数据
        写者:读取和修改数据
        约束
            允许同一时间多个读者,任何时候只能一个写者
            没有写者时,读者才能访问数据
            没有读者时,写着才能访问数据
            任何时候只能有一个线程可以操作共享变量
        共享数据
            数据集
            信号量CountMutex初始化为1,读者Rcount操作需要互斥
            信号量WriteMutex初始化为1
            整数Rconut初始化为0,表示多少个读者
            
        Writer                  Reader
            P(WriteMutex)           P(CountMutex)
            write                   if(Rcount == 0) //没有读者,证明没有锁,需要加锁
            V(WriteMutex)               P(WriteMutex) 
                                    Rcount++
                                    V(CountMutex)
                                    read
                                    P(CountMutex)
                                    Rcount--
                                    if(Rcount == 0)
                                        V(WriteMutex)
                                    V(CountMutex)
        struct{
            AR = 0 //active reader
            AW = 0 //active writer
            WR = 0 //wait reader
            WW = 0 //wait writer
            condition oktoRead oktoWrite
            lock
        }
        
        Writer                  Reader
            Start_Writer()          Start_Reader()
            write                   read
            Done_Writer()           Done_Reader()
        
        Start_Reader()                      Done_Reader()
            lock.Acquire                        lock.Acquire
            while(AW + WW > 0) {                AR--
                WR++                            if(WW > 0 && AR == 0)
                oktoRead.wait(lock) //              oktoWrite.single(lock)
                WR--                            lock.Release
            }                                   
            AR++
            lock.Release
        
        Start_Writer()                      Done_Writer()
            lock.Acquire                        lock.Acquire
            while(AW + AR > 0) {                AW--
                WW++                            if(WW > 0)
                oktoWrite.wait(lock) //             oktoWrite.single(lock)
                WW--                            else if(WR > 0)
            }                                       oktoRead.single
            AW++                                lock.Release
            lock.Release
            
    哲学家就餐
        特定数据结构,表示每个哲学家状态
        访问临界资源----进程互斥
        就餐完成后唤醒哲学家----进程同步
        #define N           5
        #define Left        i
        #define Right       (i+1)%N
        #define THINKING    0
        #define HUNGRY      1
        #define EATING      2
        int state[N]    //哲学家状态
        
        semaphore mutex = 1 //状态临界资源,互斥
        semaphore s[N]  //同步信号量,初始值0
        
        void philosopher(int i) {
            while(1) {
                think()
                take_forks()
                eat()
                put_forks()
            }
        }
        test_take_left_right_fork(int i) {
            if(state[i] == 1 &&
                state[Left] !=2 &&
                state[Right] !=2) {
                state[i] = 2
                s[i].V() //通知自己吃饭/第i人吃饭
                //自己时候,对应take_fork函数中s[i].P()
                //put_fork中的唤醒,开始别人s[i].P,别人可以吃饭的时候可以唤醒别人
        }
        
        take_forks() {
            P()
            state[i] = 1
            test_take_left_right_fork(int i)
            V()
            s[i].P() //没有叉子,自己睡眠,有叉子时候,吃完置回0
        }
        put_forks() {
            P()
            state[i] = 0
            test_take_left_right_fork(Left)
            test_take_left_right_fork(Right)
            V()
        }
    
    死锁
        可重复使用的资源
            一个时间只能一个进程使用且不能被删除
            进程获得资源,后释放由其他进程重用
            处理器,I/O通道,主/副存储器,设备和数据结构,如文件,数据库和信号量
            如果每个进程拥有一个资源并请求其他资源,死锁可能发生
        使用资源
            创建和销毁
            在I/O缓冲区的中断,信号,消息,信息
            如果接收消息阻塞可能会发生死锁
            少见组合事件可能引起死锁
        资源分配图(一组顶点V和边E的集合)
            V类型
                P = {P1,P2,P3,...,Pn} 集合系统所有进程
                R = {R1,R2,R3,...,Rn} 集合包括系统中的所有资源类型
                request/claiming Pi --> Rj
                assignment/holding Rj --> Pi
        死锁条件
            互斥,一个时间只能有一个进程使用资源
            持有并等待,进程保持至少一个资源正在等待获取其它进程持有的额外资源
            无抢占,一个资源只能被进程自愿释放
            循环等待,存在等待进程合集P,P0,等待P1,P(n-1)等待Pn,Pn等待P0
        死锁处理
            预防
            避免
                系统具有一些额外的先验证信息
                    每个进程声明它可能需要的每个类型资源的最大数目
                    资源的分配状态是通过限定提供与分配的资源数量,和进程的最大需求
                    动态检查的资源分配状态,确保永远不会有一个环形的等待状态
                        当一个进程请求可用资源,系统判断立即分配是否能使系统处于安全状态
                        序列P = {P1,P2,P3,...,Pn}是安全的,每个Pi,Pi要求的资源能够由当前可用的资源+所有的Pj持有的资源来满足,j < i
                            Pi资源的需求不是立即可用,Pi可用等到Pj完成
                            Pi完成后,P(i+1)可得到所需资源
            检测
                条件
                    多个实例
                    每个进程必须最大限度利用资源
                    当一个进程请求一个资源,不得不等待
                    一个进程获得所有的资源就必须在一段有限时间释放他们
                尝试寻找每个进程获得的最大资源并结束的进程请求的一个理想执行时序,决定一个状态是否安全
                n = 进程数量,m = 资源类型数量
                Max(总需求量) = n * m Max[i,j] = k,Pi最多请求k个资源类型Rj
                Available(剩余空闲量),Available[j] = k,有k个资源类型Rj可用
                Allocation(已分配),Allocation[i,j] = k,Pi已经分配k个Rj资源数量
                Need(未来需要量),Need[i,j] = k,Pi未来可能需要k个Rj资源数量
                    Need = Max - Allocation
                
                安全判断算法
                    1.初始化    
                        Work = Available    //当前资源剩余量
                        Finish[i] = false //进程i未结束
                    2.找i,找不到4
                        Finish[i] = false
                        Need(i) <= Wrok
                    3.转到2
                        Work = Work + Allocation(i) //进程i资源需求量小于当前剩余资源量,配置给i,等待执行完成回收
                        Finish[i] = true
                    4.
                        if Finish[i] == true //全部i处于true,表明系统处于安全,否则不安全
                银行家算法
                    1.Request(i) <= Need(i) 转到步骤2,否则提出错误条件,进程以及超过其之前宣布的最大要求
                    2.如果Request(i) <= Available,转到步骤3,否则P(i)必须等待,资源不可用
                    3.假装给P(i)分配它需要的资源,生成一个需要判断状态是否安全的资源分配环境,传给安全判断算法
                        Available = Available - Request(i)
                        Allocation = Allocation + Request(i)
                        Need(i) = Need(i) - Request(i)
                    返回safe,分配资源给P(i)
                    返回unsafe,P(i)必须等待,旧的资源分配状态被恢复
            恢复
                Available 长度为M的向量表示每种类型可用资源数量
                Allocation 一个n*m矩阵定义了当前分配给各个进程每种类型资源的数量，[i,j] = k 进程Pi拥有k个Rj资源
                Request 一个n*m矩阵表示各进程的当前请求,[i,j] = k 进程Pi请求k个Rj资源
                1.初始化,Work Finish 分别是长度m和n的向量
                    Work = available // 当前空闲
                    for i = 1...n,if Allocation(i) > 0,then finish[i] = false,otherwise finish[i] = true    //查找资源是否用完
                2.找索引i,找不到跳转4    
                    finish[i] = false
                    Request[i] < Work
                3.跳转2
                    Work = Work + Allocation[i] //找到的线程拥有的资源数释放回当前空闲资源中
                    Finish[i] = true
                4. 1 <= i <= n,系统处于死锁 Finish[i] = false Pi处于死锁
                    if Finish[i] = false,for some i,
                
                终止所有死锁进程
                在一个时间内终止一个进程直到死锁消除
                    进程优先级
                    运行多久,以及需要多少时间才能完成
                    进程占用的资源
                    进程完成需要的资源
                    多少进程需要终止
                    进程是交互还是批处理
    IPC
        概述
            通信模型
            直接及间接通信
                直接
                    send(P,msg)
                    receive(Q,msg)
                    通信链路,自动建立,一条链路对应一对进程,每队进程只能有一条,链路单/双向
                间接
                    每个消息队列唯一ID
                    只有它们共享一个消息队列,进程才能通信
                    共享一个消息队列才建立链路,链路可以多个进程关联,每对进程可以共享多个通信链路,链路单/双向
                    send(A,msg) //发送A队列
                    receive(A,msg)//从A队列接收
            阻塞与非阻塞
                阻塞被认为同步
                非阻塞被认为异步
            通信链路缓冲
                0容量,发送方等待接收方
                有限,发送方在队列慢时等待
                无限,发送方无需等待
        信号
            软件中断通知事件处理
            接收到信号处理
                Catch:指定信号处理函数被调用
                Ignore:依靠OS的默认操作
                    Abort,memory dump,suspend or resume proccess
                Mask:闭塞信号因此不会传送
            不能传输要交换数据
            Signal handles
                register handles
                dispatch to handles
                signal handler stack
        管道
            子进程从父进程继承文件描述符
            ls | more 
                ls -> (stdout 管道 stdin) more
        消息队列
            按FIFO处理信息,msg,msg Queues
        共享内存
            每个地址空间设置共享内存段
        socket
文件系统
    文件系统和文件
        分配文件磁盘空间
            管理文件块(哪一块属于哪一个文件)
            管理空闲空间(哪一块是空闲)
            分配算法
        管理文件集合
            定位文件及内容
            命名:通过名字找到文件的接口
            最常见:分层文件系统
            文件系统类型(组织文件的不同方式)
        提供的便利及特征
            保护:分层保护数据安全
            可靠性/持久性:保持文件的持久即使发生奔溃,媒体错误,工具等
        文件属性
        文件头
            保存每个文件的信息
            保存文件属性
            跟踪哪一块存储块属于逻辑上文件结构的哪个偏移
    文件描述符
        内核跟踪每个进程打开的文件,组成一个打开文件表
        一个打开文件描述符是表中的索引
        需要元数据管理打开文件
            文件指针:指向最近的一次读写位置,每个打开了这个文件的进程都有这个指针
            文件打开计数:记录文件打开的次数,最后一个进程关闭了文件时,允许从打开文件表中移除
            文件磁盘位置:缓存数据访问信息
            访问权限:每个程序访问模式信息
        系统访问接口
            字节的集合
            系统不会关心你想存储在磁盘上的任何的数据结构
        OS内部视角
            块的集合(块是逻辑转换单元,而扇区是物理转换单元)
            块大小<>扇区大小:UNIX中块大小4KB(32bytes)
        用户操作&访问
            读2-12字节空间
                获取字节所在的块,返回块内对应部分
            写2-12字节空间
                获取块,修改块内对应部分,写回块
            系统中所有操作都在整个块空间上进行,即使访问1B,也会缓存目标数据4KB
            顺序:按字节读取
                所有的访问都是这种方式
            随机:从中间读取
                不常用,但仍重要,如虚拟内存支持文件:内存页存储在文件中
                更加快速,不希望获取文件中间的内容时,也必须先获取块内所有字节
            基于内容
                许多OS不提供此种访问方式,相反,数据库是建立在索引内容的磁盘访问上
        访问控制&模式
            文件访问控制列表(ACL)
                文件实体,权限
            UNIX模式
                用户|组|所有人,rwx
                    用户ID识别用户,表明每个用户所允许的权限及保护模式
                    组ID允许用户组成组,并指定组的访问权限
                对打开文件的写入内容立即对其它打开同一文件的其它用户可见
                共享文件指针,允许多用户同时读取和写入文件
    目录
        每个目录包含一张表
        OS只允许内核模式修改目录
            确保映射的完整性
            应用程序能够读目录
        数据结构
            线性列表
            Hash表
                减少目录搜索时间
                碰撞,两个文件名的Hash值相同
                固定大小
        路径遍历
            逻辑名字转换物理资源过程
            解析/bin/ls
                读取root文件头(磁盘固定位置)-->读取root数据块,搜索bin
                读取bin文件头-->读取bin数据块,搜索ls
                读取ls
        一个文件系统需要先挂载才能被访问
    文件别名
        硬连接
            多个文件项指向一个文件
        软连接
            以快捷方式指向其他文件,指向一个路径
        处理别名
            添加间接层:目录项数据结构,文件先指向间接层
                链接 - 已存在文件的另一个名
                链接处理 - 跟随指针定位文件
            只允许到文件的连接,不允许在子目录的连接。每增加一个新的链接都用循环检测算法
    文件系统种类
        磁盘文件系统
            文件存储在数据存储设备上,磁盘
                ext3/4,ISO9660
        数据库文件系统
            文件根据特征是可被寻址(辨识)
        日志文件系统
            记录文件系统的修改和事件
                ext3/4
        网络/分布式文件系统
            NFS,SMB,AFS,GFS
    虚拟文件系统
        屏蔽不同文件系统差异
            卷控制块:superblock
                每个文件系统一个
                文件系统详细信息
                块,块大小,空余块,计数/指针等
            文件控制块:inode/vnode
                每个文件一个
                文件详细信息
                许可,拥有者,大小,数据库位置
            目录节点:dentry
                每个目录项一个
                将目录项数据结构及树型布局编码成树型数据结构
                指向文件控制块,父结点,目录项列表
        数据块缓存
            在内存中开辟一块缓存数据的区域。接下来的访问都会在内存中，即buffer数据缓冲技术
            按需读入
                预选读取后面的数据块
            使用后缓存
                假设数据将再次被使用
                写操作可能被缓存和延迟写入
            两种数据块缓存方式
                普通缓冲区缓存
                页缓存:统一缓存数据块和内存页,
                    数据块映射为页
                    文件读写转换为对内存访问
                    可能导致缺页/脏页
                    问题:页置换-从进程或文件页缓存
        文件分配
            连续分配(CDROM)
                文件头指定起始块和长度
                位置/分配策略
                    最先/佳匹配
                优点
                    高效,读取表现好
                缺点
                    已存在文件,再增长。碎片
            链式分配
                文件头包含第一块和最后一块指针
                位置/分配策略
                    最先/佳匹配
                优点
                    增大扩展容易
                缺点
                    不稳定(破坏链),不可能随机访问
            索引分配
                为每个文件创建一个索引数据块
                    到文件数据块的指针列表
                文件头包含索引数据块
                优点
                    增大扩展容易,支持直接访问
                缺点
                    文件小时,存在索引开销。如何处理大文件
                链式索引
                多级索引
                    大文件使用多级索引块
        空闲列表
            跟踪未使用的空间
            位图表示,某位 = 0,表示某个块空闲
                160G disk --> 40M blocks(4KB) --> 5MB
                    160 * 1^6 / 4 = 40M(需要40*10^6个bit表示)
                空闲空间在磁盘中均匀分布,找到0之前需要扫描n(块总数)/r(空闲数目)
            链式列表
            分组列表
        多磁盘管理
            多个数据并行读写入不同磁盘
            OS:存储/卷管理
            RAID硬件控制器(I/O)
            RAID 0,写0x2478,数据拆分写入不同硬盘中,加快读写速度
            RAID 1,写0x2478,分别写入不同硬盘中,备份作用
            RAID 4,写0x2478,数据拆分写入不同硬盘中,且校验写入一块硬盘中
            RAID 5,数据拆分且数据校验均匀分布每个磁盘中
        磁盘调度
            磁头必须定位在期望磁头,从期望的扇区开始
            平均旋转延迟时间=磁盘旋转一周时间一半
            磁盘I/O传输时间
            Ta(访问时间) = Ts(寻道时间) + 1/2r(Tr旋转延迟 1/r 旋转一周时间) + b/rN(Tt)
                T = 传输时间
                b = 传输比特数
                N = 磁道上的比特数
                r = 磁盘转数
                寻道时间是性能上区别的原因
            先进先出
            最短寻道时间
                选择从磁臂当前位置需要移动最少的I/O请求,远距离访问不到
            磁臂在一个方向上移动,满足所有为完成的请求,直到磁臂到达该方向上最后的磁道,调换方向,类似电梯
            CSCAN
                仅在一个方向扫描,最后一个磁道访问后,立即返回到磁盘的另外一端再次扫描
            CSCAN改进版
                磁臂先达到该方向上最后一个请求处,然后立即反转到磁盘的另一端
            N-step-SCAN
                磁臂粘着:进程反复请求对某一磁道的I/O操作,正在处理某子队列时,出现新I/O请求,将请求放入其它队列
                磁盘请求队列分成若干个长度为N的子队列,磁盘调度将按FCFS算法依次处理子队列,而处理每一个队列时又是按CSCAN算法
            FSCAN
                将磁盘请求队列分成两个